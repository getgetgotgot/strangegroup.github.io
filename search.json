[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Final_Report",
    "section": "",
    "text": "what is this project about\nwhat are our research questions maybe"
  },
  {
    "objectID": "index.html#principle-1-each-type-of-case-must-have-its-own-tibble.",
    "href": "index.html#principle-1-each-type-of-case-must-have-its-own-tibble.",
    "title": "Final_Report",
    "section": "2.1 Principle 1: Each type of case must have its own tibble.",
    "text": "2.1 Principle 1: Each type of case must have its own tibble.\nPrinciple 1 states that each identified type of case be stored in its own tibble. A tibble representing a specific case type should function as a clear unit of analysis and must not contain duplicated or redundant information. This often involves using functions such as select() to keep only relevant variables and distinct() to ensure that each observational unit appears only once. Storing data in such way improves storage efficiency, enhances consistency, and minimizes the risk of errors during table joins.\nTo ensure principle 1, there are two key steps:\n\nIdentify the different types of cases.\nTo do this, we first need to identify the primary key in each data set, because cases are defined as combinations of the primary key.\nChoose the variables we need and split the data into separate tibbles.\nEach tibble should include only the variables that describe that specific type of case.\n\n\n2.1.1 Monthly Survey\n2.1.1.1 What do monthly survey questionnaires contain?\nThe monthly survey is a compilation of survey responses collected across different months. Monthly survey data sets are stored in different CSV files per month (e.g. SurveyMonthly.2010_04.csv). Each data set has a similar structure, with first few rows consist of participants’ metadata, followed by survey responses that vary month by month.\nThere is a file called SurveyMonthlyQuestionKey.csv, which listed out all the scale names, scale items, and in which monthly survey were they being asked.However, based on our research questions, some of the monthly data sets are irrelevant. We will only take the data sets that are relevant to our research questions into further data tidying process.\nFirst, we imported all the monthly survey data sets into separate data frames:\n\n#creating tibbles for monthly survey per month\n\nmonthly_files &lt;- c(\n  \"InitialSurvey.csv\",\n  \"SurveyMonthly.2010_04.csv\",\n  \"SurveyMonthly.2010_05.csv\",\n  \"SurveyMonthly.2010_07.csv\",\n  \"SurveyMonthly.2010_10.csv\",\n  \"SurveyMonthly.2010_11.csv\",\n  \"SurveyMonthly.2010_12.csv\",\n  \"SurveyMonthly.2011_03.csv\",\n  \"SurveyMonthly.2011_04.csv\"\n)\n\nmonthly_names &lt;- c(\n  \"initial_df\",\n  \"month1004_df\",\n  \"month1005_df\",\n  \"month1007_df\",\n  \"month1010_df\",\n  \"month1011_df\",\n  \"month1012_df\",\n  \"month1103_df\",\n  \"month1104_df\"\n)\n\nfor(i in 1:length(monthly_files)) {\n  assign(monthly_names[i], read.csv(monthly_files[i]))\n}\n\n2.1.1.2 Primary key and cases\nAs mentioned above, apart from survey responses, all monthly survey data sets included participants’ metadata, such as participantID, start date and end date. Participants’ demographics were not collected every month, as it is listed in the SurveyMonthlyQuestionKey.csv. We deem that participantID is the primary key for every data set, beneath is one example of how we check the primary key across all monthly data sets.\n\n#check whether participantID is the primary key for monthly survey in April, 2010\n\nmonth1004_df |&gt; \n  count(participantID) |&gt; \n  filter(n&gt;1)\n\n[1] participantID n            \n&lt;0 rows&gt; (or 0-length row.names)\n\n\nWe used the same code across different monthly data sets and confirmed that participantID is indeed the primary key for all of them. Thus, participantID will be included in all separate tibbles we created to act as the foreign key.\nHowever, between different months, the survey questions do overlap according to SurveyMonthlyQuestionKey.csv. For example, for the research objectives “friendship network change”, the relevant scale is called “group involvement”, which was measured by several items across different months. For items like “Formal group involvement”, it was only measured once in the initial survey, while for items like “Formal groups participation changed“ and”Formal groups new involvement“, it is an update to previous survey responses, thus were measured in both April and May, 2010, as it is listed below.\n\n#extract relevant information for \"group involvement scale\"\n\nsurvey_key = read_excel(\"SurveyMonthlyQuestionKey.xlsx\")\ngroup_itemskey = survey_key |&gt; \n  slice(c(168:171, 186:195))\nview(group_itemskey)\n\nIn the next step, we extract items like “Formal groups participation changed“ and”Formal groups new involvement“ from different monthly survey and store them in different tibbles (e.g. mar_group, apr_group, as mentioned in the following paragraphs). Therefore, the cases we are using contains both (participant) and (participant, month), with the former one focused on participants’ demographics, and the latter one for variables that are related to our research questions.\n2.1.1.3 Creating tibbles for different cases\nInitial Survey/March, 2010\nThis data sets contains both participants’ metadata, demographics and responses to survey items. Cases for this data set are (participant) and (participant, month).\na. Demographics\nFor the case (participant), we create separate tibble for demographics from initial survey. More specifically, the demographic tibble only includes participants’ ID, and participants’ gender. Due to privacy issues, sensitive information such as apartment number, name, cell phone number, etc. were already removed or anonymised in the original data sets, thus were removed from the tibble. Information like start date and end date are not characteristics of the participants, thus were also removed from the tibble.\n\nmar_demo = initial_df |&gt; \n  select(c(1,14)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\nb. Group participation\n\nmar_group = initial_df |&gt; \n  select(c(1, 53:76)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\nc. Communication with friends\n\nmar10_commu = initial_df |&gt; \n  select(c(1, 277:280)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\nMonthly survey April, 2010\na. Big 5\n\napr_big5 = month1004_df |&gt; \n  select(c(1, 11:54)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\nb. Group participation\n\napr_group = month1004_df |&gt; \n  select(c(1, 55:114)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\nMonthly survey May, 2010\na. Group participation\n\nmay_group = month1005_df |&gt;\n  select(c(1, 73:132)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\nb. Well-being\n\nmay_well_being = month1005_df |&gt; \n  select(c(1, 32:72)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\nMonthly survey October, 2010\na. Aerobic exercise actual\n\noct_exe_act = month1010_df |&gt;    \n  select(c(1, 62)) |&gt;    \n  distinct() |&gt;    \n  arrange(participantID)\n\nb. Sleep actual\n\noct_sleep_act = month1010_df |&gt; \n  select(c(1, 80)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\nMonthly survey March, 2011\nCommunication with friends\n\nmar11_commu = month1103_df |&gt; \n  select(c(1, 26:30)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\n\n\n2.1.2 Location\nLocation every 30 minutes (Location.csv.bz2), with each record including the participant ID associated with the data-collecting mobile phone (participantID), the date-time when the location is recorded (date), the the 68% confidence offset of the estimation from true location(accuracy, in meters), and the estimated location affine-transformed (x, y).\n\n#create a tibble for Location.csv, and have a preview of the data set\n\nlocation_df = read.csv(\"Location.csv\") |&gt; \narrange(participantID)\n\nWe tried to define the primary key, however, even if we combine all the column names together, the combination itself still cannot identify every single row uniquely, as it is shown in the following code:\n\n#check whether (participantID, date, accuracy, x, y) is the primary key\n\nlocation_df |&gt; \n  count(participantID, date, accuracy, x, y) |&gt; \n  filter(n&gt;1) |&gt; \n  head()\n\n  participantID                date accuracy     x    y n\n1    fa10-01-04 2010-09-29 13:22:53       65 11009 6426 2\n2    fa10-01-04 2010-09-29 13:52:11       13 11223 6036 2\n3    fa10-01-04 2010-09-29 14:03:03        7  6314 5130 2\n4    fa10-01-04 2010-09-29 14:12:59      871   670  987 2\n5    fa10-01-04 2010-09-29 14:22:59       60   -12  -35 2\n6    fa10-01-07 2010-12-07 15:13:12        9  4563 4925 2\n\n\nWe deemed that the duplicates were produced due to faulty data collection methods after reviewing the data description. Thus, we decided to remove duplicated data that has the exact value under every variable:\n\nlocation_df = location_df |&gt; distinct()\n\nIn the new data frame, we found that (participantID, date) is the primary key, as it is shown in the following code:\n\n#check whether (participantID, date) is the primary key\n\nlocation_df |&gt; \n  count(participantID, date) |&gt; \n  filter(n&gt;1)\n\n[1] participantID date          n            \n&lt;0 rows&gt; (or 0-length row.names)\n\n\nIn the final data frame, for the case participant ID, no characteristic was involved. For the case (participantID, date), we created a separate tibble according to principle 1:\n\ndate_coordinates = location_df |&gt; \n  select(participantID, date, x, y) |&gt; \n  distinct() |&gt; \n  arrange(participantID)"
  },
  {
    "objectID": "index.html#principle-2-each-observation-must-have-its-own-row.-draft-ver.",
    "href": "index.html#principle-2-each-observation-must-have-its-own-row.-draft-ver.",
    "title": "Final_Report",
    "section": "2.2 Principle 2: Each observation must have its own row. (Draft ver.)",
    "text": "2.2 Principle 2: Each observation must have its own row. (Draft ver.)\nwhat is principle 2… For principle 2, the researcher needed to ensure that no multiple observations were stacked into the same row. In order to achieve that, the researcher first examined all 11 tibbles created from the first step to spot repeated information. Then, the researcher should delete repeated information among different rows.\n\n2.2.1 Monthly Survey\na. Demographics\n\n#check to count the distinct values within Gender\n\nmar_demo |&gt; \n  count(Gender)\n\n  Gender  n\n1      F 14\n2 Female 35\n3      M 13\n4   Male 51\n5      f  1\n6 female 25\n7      m  1\n8   male 15\n\n\n\n# recode the values in Gender to be consistent and use the same expressions\n\nmar_demo &lt;- mar_demo |&gt; \n  transmute(participantID = participantID,\n            Gender =\n              recode(Gender,\n                     \"F\" = \"Female\",\n                     \"f\" = \"Female\",\n                     \"female\" = \"Female\",\n                     \"M\" = \"Male\",\n                     \"m\" = \"Male\",\n                     \"male\" = \"Male\"))\n\n#check to count the distinct values within Gender\n\nmar_demo |&gt; \n  count(Gender)\n\n  Gender  n\n1 Female 75\n2   Male 80\n\nView(mar_demo)\n\nThere were in total 86 + 56 = 142 participants, but only 141 rows were found in mar_demo. The researcher then explored the missing participant and filled in their data with NA value.\n\n# check if there are participants missing from the demographics df.\n\nall_participants &lt;- c(paste0(\"fa10-01-\", sprintf(\"%02d\", 1:86)),\n                      paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56)))\nsetdiff(all_participants, mar_demo$participantID)\n\n[1] \"fa10-01-84\"\n\n# add the row for the missing participant fa10-01-84.\n\nmar_demo &lt;- mar_demo |&gt; \n  add_row(Gender = NA, participantID = 'fa10-01-84') |&gt; \n  arrange(participantID)\n\nb. Group Participation\n\n# delete rows with all NA values because they provide essentially no information.\n\nmar_group &lt;- mar_group |&gt; \n  filter(!if_all(-participantID, ~is.na(.)))\n\nThere should be 56 participants with answers for Group Participation, but only 55 rows of data were there. The researcher then explored the missing participant.\n\n# explore which participant is missing from the data frame.\n\nall_participants &lt;- c(paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56)))\nsetdiff(all_participants, mar_group$participantID)\n\n[1] \"sp10-01-53\"\n\n\nIn addition, the researcher noticed that the NA values were not consistently represented in all cells, so the researcher decided to recode values to retain consistency.\n\n# fill all empty cells with NA values\n\nmar_group &lt;- mar_group |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\nc. Communication with friends\n\n# delete rows with all NA values because they provide essentially no information.\n\nmar10_commu &lt;- mar10_commu |&gt; \n  filter(!if_all(-participantID, ~is.na(.)))\n\n# fill all empty cells with NA values\n\nmar10_commu &lt;- mar10_commu |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\n\n# explore how many participants are missing from the mar10_commu df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56)),\n  paste0(\"fa10-01-\", sprintf(\"%02d\", 1:40))\n)\nsetdiff(all_participants, mar10_commu$participantID) |&gt; \n  length()\n\n[1] 18\n\n\nMonthly survey April, 2010\na. Big 5\n\n# fill all empty cells with NA values\n\napr_big5 &lt;- apr_big5 |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\n\n# explore how many participants are missing from the apr_big5 df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56))\n)\nsetdiff(all_participants, apr_big5$participantID) |&gt; \n  length()\n\n[1] 3\n\nView(apr_big5)\n\nb. Group participation\n\n# fill all empty cells with NA values\n\napr_group &lt;- apr_group |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\n# delete rows with all NA values because they provide essentially no information.\n\napr_group &lt;- apr_group |&gt; \n  filter(!if_all(-participantID, ~is.na(.)))\n\n\n# explore how many participants are missing from the apr_group df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56))\n)\nsetdiff(all_participants, apr_group$participantID) |&gt; \n  length()\n\n[1] 23\n\n\n\n# explore how many participants are missing from the apr_group df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56))\n)\nsetdiff(all_participants, apr_group$participantID) |&gt; \n  length()\n\n[1] 23\n\n\nThe researcher spotted several repeated values in the columns and decided to pivot the columns into multiple rows for each different observation.\n\n# change the data type into character\n\napr_group &lt;- apr_group |&gt;\n  mutate(across(-participantID, as.character))\n\n# change the data type for group number into integar\n\nMonthly survey May, 2010\na. Group participation\n\nmay_group = month1005_df |&gt;\n  select(c(1, 73:132)) |&gt; \n  distinct() |&gt; \n  arrange(participantID)\n\n\n# fill all empty cells with NA values\n\nmay_group &lt;- may_group |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\n# delete rows with all NA values because they provide essentially no information.\n\nmay_group &lt;- may_group |&gt; \n  filter(!if_all(-participantID, ~is.na(.)))\n\n# explore how many participants are missing from the apr_group df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56))\n)\nsetdiff(all_participants, may_group$participantID) |&gt; \n  length()\n\n[1] 34\n\n\nb. Well-being\n\n# fill all empty cells with NA values\n\nmay_well_being &lt;- may_well_being |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\n# delete rows with all NA values because they provide essentially no information.\n\nmay_well_being &lt;- may_well_being |&gt; \n  filter(!if_all(-participantID, ~is.na(.)))\n\n# explore how many participants are missing from the may_well_being df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56))\n)\nsetdiff(all_participants, may_well_being$participantID) |&gt; \n  length()\n\n[1] 14\n\n\nMonthly survey October, 2010\na. Aerobic exercise actual\n\n# fill all empty cells with NA values\n\noct_exe_act &lt;- oct_exe_act |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\n# delete rows with all NA values because they provide essentially no information.\n\noct_exe_act &lt;- oct_exe_act |&gt; \n  filter(!if_all(-participantID, ~is.na(.)))\n\n# explore how many participants are missing from the oct_exe_act df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56)),\n  paste0(\"fa10-01-\", sprintf(\"%02d\", 1:40))\n)\nsetdiff(all_participants, oct_exe_act$participantID) |&gt; \n  length()\n\n[1] 18\n\n\nb. Sleep actual\n\n# fill all empty cells with NA values\n\noct_sleep_act &lt;- oct_sleep_act |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\n# delete rows with all NA values because they provide essentially no information.\n\noct_sleep_act &lt;- oct_sleep_act |&gt; \n  filter(!if_all(-participantID, ~is.na(.)))\n\n# explore how many participants are missing from the oct_sleep_act df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56)),\n  paste0(\"fa10-01-\", sprintf(\"%02d\", 1:40))\n)\nsetdiff(all_participants, oct_sleep_act$participantID) |&gt; \n  length()\n\n[1] 19\n\n\nMonthly survey March, 2011\nCommunication with friends\n\n# delete rows with all NA values because they provide essentially no information.\n\nmar11_commu &lt;- mar11_commu |&gt; \n  filter(!if_all(-participantID, ~is.na(.)))\n\n# fill all empty cells with NA values\n\nmar11_commu &lt;- mar11_commu |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\n# explore how many participants are missing from the mar11_commu df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56)),\n  paste0(\"fa10-01-\", sprintf(\"%02d\", 1:40))\n)\nsetdiff(all_participants, mar11_commu$participantID) |&gt; \n  length()\n\n[1] 32\n\n\n\n\n2.1.2 Location\n\n# delete possible repeated rows\n\ndate_coordinates &lt;- date_coordinates |&gt; \n  distinct(participantID, date, x, y, .keep_all = TRUE)\n\n# fill all empty cells with NA values\n\ndate_coordinates &lt;- date_coordinates |&gt; \n  mutate(across(where(is.character), ~ na_if(.x, \"\"))) |&gt; \n  distinct()\n\n# delete rows with all NA values because they provide essentially no information.\n\ndate_coordinates &lt;- date_coordinates |&gt; \n  filter(!if_all(-participantID, ~is.na(.)))\n\n# explore how many participants are missing from the date_coordinates df.\n\nall_participants &lt;- c(\n  paste0(\"sp10-01-\", sprintf(\"%02d\", 1:56)),\n  paste0(\"fa10-01-\", sprintf(\"%02d\", 1:40))\n)\nsetdiff(all_participants, date_coordinates$participantID) |&gt; \n  length()\n\n[1] 11"
  },
  {
    "objectID": "index.html#principle-3-each-variable-must-have-its-own-column.-draft-ver.",
    "href": "index.html#principle-3-each-variable-must-have-its-own-column.-draft-ver.",
    "title": "Final_Report",
    "section": "2.3 Principle 3: Each variable must have its own column. (Draft ver.)",
    "text": "2.3 Principle 3: Each variable must have its own column. (Draft ver.)\nAccording to the third principle, each variable must have its own column, and each column must be a variable. This implies, also, that each variable must be stored in its unique, separate column. Headers must be variable names, and not data; variables must not appear in both rows and columns.\n\n2.3.1 Monthly Survey\nFor each of the relevant monthly survey tibbles, we must perform adequate tidying in accord with the principle.\nInitial Survey/March, 2010\nGroup participation\nWe may first inspect the original tibble. As seen below, column headers contain multiple types of information: besides the belonging/involvement variable, they also contain group number (1-6) and group type (formal/informal). This is in violation with principle three as stated above.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparticipantID\nFormal.groups.belong.to..Group.1.\nFormal.groups.belong.to..Group.2.\nFormal.groups.belong.to..Group.3.\nFormal.groups.belong.to..Group.4.\nFormal.groups.belong.to..Group.5.\nFormal.groups.belong.to..Group.6.\nFormal.group.involvement..Group.1.\nFormal.group.involvement..Group.2.\nFormal.group.involvement..Group.3.\nFormal.group.involvement..Group.4.\nFormal.group.involvement..Group.5.\nFormal.group.involvement..Group.6.\nInformal.groups.belong.to..Group.1.\nInformal.groups.belong.to..Group.2.\nInformal.groups.belong.to..Group.3.\nInformal.groups.belong.to..Group.4.\nInformal.groups.belong.to..Group.5.\nInformal.groups.belong.to..Group.6.\nInformal.group.involvement..Group.1.\nInformal.group.involvement..Group.2.\nInformal.group.involvement..Group.3.\nInformal.group.involvement..Group.4.\nInformal.group.involvement..Group.5.\nInformal.group.involvement..Group.6.\n\n\n\n\nsp10-01-01\nmedia lab smart cities group\nNA\nNA\nNA\nNA\nNA\n4\nNA\nNA\nNA\nNA\nNA\npottery\nswimming\nNA\nNA\nNA\nNA\n3\n1\nNA\nNA\nNA\nNA\n\n\nsp10-01-02\nHarvard Extension school master program\nNA\nNA\nNA\nNA\nNA\n2\nNA\nNA\nNA\nNA\nNA\nRunning group\nYoga group\nNA\nNA\nNA\nNA\n3\n2\nNA\nNA\nNA\nNA\n\n\nsp10-01-03\nPottery Class\nChinese Painting\nSOCS (student club)\nNA\nNA\nNA\n2\n2\n2\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nsp10-01-04\npottery class\nNA\nNA\nNA\nNA\nNA\n1\nNA\nNA\nNA\nNA\nNA\nwork colleagues\nNA\nNA\nNA\nNA\nNA\n1\nNA\nNA\nNA\nNA\nNA\n\n\nsp10-01-05\nWIFV/NE\nInternational Student Association - Emerson College\nEmerson College VMA Graduates\nNA\nNA\nNA\n4\n3\n4\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n\n\n\nFirst, we investigate the belonging columns. We use the pivot_longerfunction to transition from the wide format to a longer one, with new column headers Formal_Or_Informal and Group_Number storing the names either preceding or appended to the Group_Belongingvariable. The problem lays with the fact that the variable Group_Number does not store the value of the ith group for each of the n participants, but the value of the ith formal or ith informal group. This is lacking in clarity. We thus simply count the rows which share the same participantID.\n\nmar_group_belonging &lt;- mar_group |&gt;\n  select(participantID, contains(\"belong.to\"))|&gt;\n  pivot_longer(\n    cols = 'Formal.groups.belong.to..Group.1.': 'Informal.groups.belong.to..Group.6.',\n    names_to = c(\"Formal_or_Informal\", \"Group_Number\"),\n    names_pattern = \"(Formal|Informal)\\\\.groups\\\\.belong\\\\.to\\\\.\\\\.Group\\\\.(\\\\d+)\\\\.\",\n    values_to = \"Group_Belonging\",\n    values_drop_na = TRUE) |&gt;\n  group_by(participantID) |&gt;\n  mutate(\n    Group_Number = row_number()\n  ) |&gt;\n  ungroup() \n\nSecond, the same procedure is applied to the involvement columns.\n\nmar_group_involvement &lt;- mar_group |&gt;\n  select(participantID, contains(\".involvement\"))|&gt;\n  pivot_longer(\n    cols = 'Formal.group.involvement..Group.1.': 'Informal.group.involvement..Group.6.',\n    names_to = c(\"Formal_or_Informal\", \"Group_Number\"),\n    names_pattern = \"(Formal|Informal)\\\\.group\\\\.involvement\\\\.\\\\.Group\\\\.(\\\\d+)\\\\.\",\n    values_to = \"Group_Involvement\",\n    values_drop_na = TRUE) |&gt;\n    group_by(participantID) |&gt;\n    mutate(\n      Group_Number = row_number()\n    ) |&gt;\n    ungroup() \n\nLast, we left join the two artificially split tibbles to recreate the full one. mar_group_involvement features 229 observations, and mar_group_belonging features 227, meaning that certain belonged-to groups have missing values for involvement. By left-joining on belonging, we capture those cases as well.\n\nmar_group &lt;- left_join(\n  mar_group_belonging,         \n  mar_group_involvement,     \n  by = c(\"participantID\", \"Group_Number\", \"Formal_or_Informal\")\n) |&gt;\n  select(participantID, Group_Number, Group_Belonging, Group_Involvement, Formal_or_Informal)\n\nThe clean tibble now looks like:\n\n\n\n\n\n\n\n\n\n\n\n\nparticipantID\nGroup_Number\nGroup_Belonging\nGroup_Involvement\nFormal_or_Informal\n\n\n\n\nsp10-01-01\n1\nmedia lab smart cities group\n4\nFormal\n\n\nsp10-01-01\n2\npottery\n3\nInformal\n\n\nsp10-01-01\n3\nswimming\n1\nInformal\n\n\nsp10-01-02\n1\nHarvard Extension school master program\n2\nFormal\n\n\nsp10-01-02\n2\nRunning group\n3\nInformal\n\n\n\n\n\nCommunication\nGlimpse the communication table before principle three is applied. As can be noticed, one variable is here spread across several columns (channel of communication with friends). Frequencies are measured in terms of participant and channel.\n\n\n\n\n\n\n\n\n\n\n\n\nparticipantID\nCommunicate.remote.friends..phone..landline.or.cell.phone.\nCommunicate.remote.friends..internet.phone..ex..Skype.\nCommunicate.remote.friends..text.message.SMS\nCommunicate.remote.friends..online.chat.instant.message\n\n\n\n\nfa10-01-01\nonce or twice a week\nonce or twice a week\nonce or twice a week\nnever\n\n\nfa10-01-02\nnever\nless than once a month\nnever\nnever\n\n\nfa10-01-03\nnever\nonce or twice a month\nnever\nonce or twice a month\n\n\nfa10-01-04\nnever\nonce or twice a week\nNA\non most days\n\n\nfa10-01-05\nonce or twice a month\nonce or twice a month\nless than once a month\nonce or twice a month\n\n\n\n\n\nWe simply pivot from wide format to long, filling in the values with the strings succeeding ‘friends’ and replacing the dots with blank spaces for clarity.\n\nmar10_commu &lt;- mar10_commu |&gt;\n  pivot_longer(\n    cols = -participantID,\n    names_to = \"Channel\",\n    names_pattern =\"Communicate\\\\.remote\\\\.friends\\\\.\\\\.(.*)\",\n    values_to = \"Frequency\") |&gt;\n  mutate(\n    Channel = str_replace_all(Channel, \"\\\\.\", \" \") \n  )\n\nNow the output looks like this:\n\n\n\n\n\nparticipantID\nChannel\nFrequency\n\n\n\n\nfa10-01-01\nphone landline or cell phone\nonce or twice a week\n\n\nfa10-01-01\ninternet phone ex Skype\nonce or twice a week\n\n\nfa10-01-01\ntext message SMS\nonce or twice a week\n\n\nfa10-01-01\nonline chat instant message\nnever\n\n\nfa10-01-02\nphone landline or cell phone\nnever\n\n\n\n\n\nMonthly survey April, 2010\nGroup participation\nGroup participation for the months following the initial survey is slightly more complex: we now have groups participants have stopped being a part of, groups participants have joined (with a new involvement variable) and groups participants had previously been a part of, but for which the level of involvement has changed. Still, a similar type of problematic data structure persists, as with the previous group participation tibble.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparticipantID\nFormalgroupsstopped.Group1\nFormalgroupsstopped.Group2\nFormalgroupsstopped.Group3\nFormalgroupsstopped.Group4\nFormalgroupsstopped.Group5\nFormalgroupsstopped.Group6\nFormalgroupsparticipationchanged.Group1\nFormalgroupsparticipationchanged.Group2\nFormalgroupsparticipationchanged.Group3\nFormalgroupsparticipationchanged.Group4\nFormalgroupsparticipationchanged.Group5\nFormalgroupsparticipationchanged.Group6\nFormalgroupsnewinvolvement.Group1\nFormalgroupsnewinvolvement.Group2\nFormalgroupsnewinvolvement.Group3\nFormalgroupsnewinvolvement.Group4\nFormalgroupsnewinvolvement.Group5\nFormalgroupsnewinvolvement.Group6\nFormalgroupsjoined.Group1\nFormalgroupsjoined.Group2\nFormalgroupsjoined.Group3\nFormalgroupsjoined.Group4\nFormalgroupsjoined.Group5\nFormalgroupsjoined.Group6\nFormalgroupsjoinedinvolvement.Group1\nFormalgroupsjoinedinvolvement.Group2\nFormalgroupsjoinedinvolvement.Group3\nFormalgroupsjoinedinvolvement.Group4\nFormalgroupsjoinedinvolvement.Group5\nFormalgroupsjoinedinvolvement.Group6\nInformalgroupsstopped.Group1\nInformalgroupsstopped.Group2\nInformalgroupsstopped.Group3\nInformalgroupsstopped.Group4\nInformalgroupsstopped.Group5\nInformalgroupsstopped.Group6\nInformalgroupsparticipationchanged.Group1\nInformalgroupsparticipationchanged.Group2\nInformalgroupsparticipationchanged.Group3\nInformalgroupsparticipationchanged.Group4\nInformalgroupsparticipationchanged.Group5\nInformalgroupsparticipationchanged.Group6\nInformalgroupsnewinvolvement.Group1\nInformalgroupsnewinvolvement.Group2\nInformalgroupsnewinvolvement.Group3\nInformalgroupsnewinvolvement.Group4\nInformalgroupsnewinvolvement.Group5\nInformalgroupsnewinvolvement.Group6\nInformalgroupsjoined.Group1\nInformalgroupsjoined.Group2\nInformalgroupsjoined.Group3\nInformalgroupsjoined.Group4\nInformalgroupsjoined.Group5\nInformalgroupsjoined.Group6\nInformalgroupsjoinedinvolvement.Group1\nInformalgroupsjoinedinvolvement.Group2\nInformalgroupsjoinedinvolvement.Group3\nInformalgroupsjoinedinvolvement.Group4\nInformalgroupsjoinedinvolvement.Group5\nInformalgroupsjoinedinvolvement.Group6\n\n\n\n\nsp10-01-02\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nYoga group\nNA\nNA\nNA\nNA\nNA\n3\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nsp10-01-03\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nmit creativity discussions\nNA\nNA\nNA\nNA\nNA\n5\nNA\nNA\nNA\nNA\nNA\n\n\nsp10-01-04\nNA\nNA\nNA\nNA\nNA\nNA\npottery\nNA\nNA\nNA\nNA\nNA\n2\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nsp10-01-06\nKickboxing\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nsp10-01-08\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nWestgate Yoga Class\nNA\nNA\nNA\nNA\nNA\n2\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nWestgate Gardening\nNA\nNA\nNA\nNA\nNA\n1\nNA\nNA\nNA\nNA\nNA\n\n\n\n\n\nFirst, we handle all columns not partaking to involvement. The first part of the column marks the type of group, the middle the action the participant has engaged in (joined/stopped/alerted participation), and the last the group number, which we must again change to number of rows associated with one participantID. We drop the NAs so we obtain only the groups for which an action and description was ascribed.\n\napr_group_descript &lt;- apr_group|&gt;\n  select(participantID, !contains(\"involvement\"))|&gt;\n  pivot_longer(\n    cols = -participantID,\n    names_to = c(\"Formal_or_Informal\", \"Group_Action\", \"Group_Number\"),\n    names_pattern = \"(Formal|Informal)groups(.*)\\\\.Group(\\\\d+)\",\n    values_to = \"Group_Belonging\",\n    values_drop_na = TRUE)|&gt;\n  group_by(participantID)|&gt;\n  mutate(\n    Group_Number = row_number())\n\nWe handle involvement in a similar fashion. We drop NAs so we obtain only the groups for which a level of involvement was specified.\n\napr_group_involvement &lt;- apr_group|&gt;\n  select(participantID, contains(\"involvement\"))|&gt;\n  pivot_longer(\n    cols = -participantID,\n    names_to = c(\"Formal_or_Informal\", \"Involvement_Type\", \"Group_Number\"),\n    names_pattern = \"(Formal|Informal)groups(.*)\\\\.Group(\\\\d+)\",\n    values_to = \"Group_Involvement\",\n    values_drop_na =TRUE)|&gt;\n  group_by(participantID)|&gt;\n  mutate(\n    Group_Number = row_number())\n\nFinally, we left-join the two on apr_group_descript, so we do not miss out the 13 values for which a group was described, but an involvement level not specified.\n\napr_group &lt;- left_join(\n  apr_group_descript,         \n  apr_group_involvement,     \n  by = c(\"participantID\", \"Group_Number\", \"Formal_or_Informal\")\n) |&gt;\n  select(participantID, Group_Number, Group_Action, Group_Belonging, Group_Involvement, Formal_or_Informal)\n\nThe final tibble now looks like:\n\n\n\n\n\n\n\n\n\n\n\n\n\nparticipantID\nGroup_Number\nGroup_Action\nGroup_Belonging\nGroup_Involvement\nFormal_or_Informal\n\n\n\n\nsp10-01-02\n1\nparticipationchanged\nYoga group\n3\nInformal\n\n\nsp10-01-03\n1\njoined\nmit creativity discussions\n5\nInformal\n\n\nsp10-01-04\n1\nparticipationchanged\npottery\n2\nFormal\n\n\nsp10-01-06\n1\nstopped\nKickboxing\nNA\nFormal\n\n\nsp10-01-08\n1\njoined\nWestgate Yoga Class\n2\nFormal\n\n\n\n\n\nMonthly survey May, 2010\nGroup participation\nThe same procedure as above was applied to this tibble, as the data structure was identical to April, 2010.\n\n#Pivoting group description and action tibble\nmay_group_descript &lt;- may_group|&gt;\n  select(participantID, !contains(\"involvement\"))|&gt;\n  pivot_longer(\n    cols = -participantID,\n    names_to = c(\"Formal_or_Informal\", \"Group_Action\", \"Group_Number\"),\n    names_pattern = \"(Formal|Informal)groups(.*)\\\\.Group(\\\\d+)\",\n    values_to = \"Group_Belonging\",\n    values_drop_na = TRUE)|&gt;\n  group_by(participantID)|&gt;\n  mutate(\n    Group_Number = row_number())\n#Pivoting involvement tibble\nmay_group_involvement &lt;- may_group|&gt;\n  select(participantID, contains(\"involvement\"))|&gt;\n  pivot_longer(\n    cols = -participantID,\n    names_to = c(\"Formal_or_Informal\", \"Involvement_Type\", \"Group_Number\"),\n    names_pattern = \"(Formal|Informal)groups(.*)\\\\.Group(\\\\d+)\",\n    values_to = \"Group_Involvement\",\n    values_drop_na =TRUE)|&gt;\n  group_by(participantID)|&gt;\n  mutate(\n    Group_Number = row_number())\n#Putting the two separated tibbles together\nmay_group &lt;- left_join(\n  may_group_descript,         \n  may_group_involvement,     \n  by = c(\"participantID\", \"Group_Number\", \"Formal_or_Informal\")\n) |&gt;\n  select(participantID, Group_Number, Group_Action, Group_Belonging, Group_Involvement, Formal_or_Informal)\n\nMonthly survey March, 2011\nCommunication with friends\nThe initial tibble is very similar to the 2010 communication one, except that the pattern the column names follow is slightly different.\n\n\n\n\n\n\n\n\n\n\n\n\n\nparticipantID\nCommunicateremotefriends.phone.landlineorcellphone.\nCommunicateremotefriends.internetphone.ex.Skype.\nCommunicateremotefriends.textmessage.SMS\nCommunicateremotefriends.email\nCommunicateremotefriends.onlinechat.instantmessage\n\n\n\n\nfa10-01-02\nnever\nonce or twice a month\nnever\nless than once a month\nnever\n\n\nfa10-01-03\nnever\nonce or twice a month\nnever\nonce or twice a month\nonce or twice a month\n\n\nfa10-01-04\non most days\non most days\non most days\non most days\non most days\n\n\nfa10-01-05\nonce or twice a month\nonce or twice a month\nonce or twice a week\nonce or twice a month\nless than once a month\n\n\nfa10-01-06\nonce or twice a week\nless than once a month\nonce or twice a week\nonce or twice a week\nnever\n\n\n\n\n\nWe thus update the name_pattern argument.\n\nmar11_commu &lt;- mar11_commu |&gt;\n  pivot_longer(\n    cols = -participantID,\n    names_to = \"Channel\",\n    names_pattern =\"Communicateremotefriends\\\\.(.*)\",\n    values_to = \"Frequency\") |&gt;\n  mutate(\n    Channel = str_replace_all(Channel, \"\\\\.\", \" \") \n  )\n\nResult:\n\n\n\n\n\nparticipantID\nChannel\nFrequency\n\n\n\n\nfa10-01-02\nphone landlineorcellphone\nnever\n\n\nfa10-01-02\ninternetphone ex Skype\nonce or twice a month\n\n\nfa10-01-02\ntextmessage SMS\nnever\n\n\nfa10-01-02\nemail\nless than once a month\n\n\nfa10-01-02\nonlinechat instantmessage\nnever"
  }
]